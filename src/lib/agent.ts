import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { exec, ExecException } from 'child_process';
import { GeminiClient } from './gemini';

export class AutoDocAgent {
    private gemini: GeminiClient;
    private logCallback: (msg: string) => void;
    private workspaceRoot: string;

    constructor(logCallback: (msg: string) => void) {
        this.gemini = new GeminiClient();
        this.logCallback = logCallback;
        if (!vscode.workspace.workspaceFolders) {
            throw new Error('No workspace folder open');
        }
        this.workspaceRoot = vscode.workspace.workspaceFolders[0].uri.fsPath;
    }

    public async run(topic: string) {
        try {
            this.log(`üéØ Topic received: "${topic}"`);

            // 1. Plan & Initial Draft
            this.log('‚ú® Gemini is drafting the content...');
            let currentMarkdown = await this.gemini.generateContent(this.createSystemPrompt(topic));

            let attempts = 0;
            const maxAttempts = 3;
            let success = false;
            let finalOutput = '';

            while (attempts < maxAttempts) {
                attempts++;
                this.log(`‚öôÔ∏è Attempt ${attempts}/${maxAttempts}: Extracting and verifying code...`);

                const codeBlock = this.extractCode(currentMarkdown);
                if (!codeBlock) {
                    this.log('‚ö†Ô∏è No code block found. Asking Gemini to regenerate...');
                    currentMarkdown = await this.gemini.generateContent(
                        `The previous response did not contain a valid Node.js code block. Please rewrite the explanation and include a valid Node.js code block.\nTopic: ${topic}`
                    );
                    continue;
                }

                // 2. Save Code to Temp File
                const tempFileName = `autodoc-temp-${Date.now()}.js`;
                const tempFilePath = path.join(this.workspaceRoot, tempFileName);
                fs.writeFileSync(tempFilePath, codeBlock);
                this.log(`üíæ Code saved to ${tempFileName}`);

                // 3. Execute Code
                this.log('üíª Executing code...');
                try {
                    const { stdout, stderr } = await this.executeScript(tempFilePath);

                    if (stderr && stderr.trim().length > 0) {
                        // Check if it's just a warning or a real error. For now, treat as error if exit code was non-zero (handled by executeScript rejection).
                        // However, child_process.exec doesn't reject on stderr unless exit code is non-zero.
                        // We will assume if exit code is 0, it's fine even with stderr (some libs print info to stderr).
                        // But if we are here, it means execution finished.
                        this.log(`‚ö†Ô∏è Stderr detected: ${stderr.substring(0, 50)}...`);
                    }

                    this.log('‚úÖ Execution successful!');
                    finalOutput = stdout;
                    success = true;

                    // Cleanup temp file
                    fs.unlinkSync(tempFilePath);
                    break;

                } catch (error: any) {
                    const errorMessage = error.message || String(error);
                    this.log(`üî• Execution failed: ${errorMessage}`);
                    this.log('üîß Requesting self-correction from Gemini...');

                    // 4. Self-Correction
                    const fixPrompt = `
I tried to execute the code you provided, but it failed with the following error:
\`\`\`
${errorMessage}
\`\`\`
Please fix the code to resolve this error. Ensure you use ONLY standard Node.js modules.
Regenerate the entire Markdown response with the corrected code.
`;
                    currentMarkdown = await this.gemini.generateContent(fixPrompt);
                }
            }

            if (!success) {
                this.log('‚ùå Failed to generate working code after maximum attempts.');
                throw new Error('Failed to generate working code.');
            }

            // 5. Final Assembly & Preview
            this.log('üìù assembling final document...');
            const finalDocContent = `
${currentMarkdown}

## Execution Output
\`\`\`text
${finalOutput}
\`\`\`

> *Generated by Auto-Doc Agent (Gemini)*
`;

            // Ensure result directory exists
            const resultDir = path.join(this.workspaceRoot, 'result');
            if (!fs.existsSync(resultDir)) {
                fs.mkdirSync(resultDir);
            }

            const fileName = `doc-${topic.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.md`;
            const filePath = path.join(resultDir, fileName);
            fs.writeFileSync(filePath, finalDocContent);

            this.log(`üíæ Document saved to ${fileName}`);

            // Open Preview
            const docUri = vscode.Uri.file(filePath);
            await vscode.commands.executeCommand('markdown.showPreview', docUri);

            this.log('‚ú® Done! Preview opened.');
            return true;

        } catch (e: any) {
            this.log(`‚ùå Critical Error: ${e.message}`);
            throw e;
        }
    }

    private log(msg: string) {
        this.logCallback(msg);
    }

    private createSystemPrompt(topic: string): string {
        return `
You are an expert technical writer and developer.
Your task is to write a Markdown tutorial about: "${topic}".

Requirements:
1. Provide a clear explanation of the concept.
2. Include a COMPLETE, EXECUTABLE Node.js code block that demonstrates the concept.
3. The code MUST use ONLY standard Node.js modules (fs, path, crypto, etc.). DO NOT use third-party libraries like axios, express, etc.
4. The code MUST print useful output to stdout to demonstrate it works.
5. The code MUST end with \`process.exit(0)\` upon success.
6. Add the comment "// Security Note: This code is AI-generated and not sandboxed." at the top of the code.

Format:
- Markdown text.
- One main code block using \`\`\`javascript or \`\`\`js.
`;
    }

    private extractCode(markdown: string): string | null {
        const regex = /```(?:javascript|js)([\s\S]*?)```/;
        const match = markdown.match(regex);
        return match ? match[1].trim() : null;
    }

    private executeScript(filePath: string): Promise<{ stdout: string, stderr: string }> {
        return new Promise((resolve, reject) => {
            exec(`node "${filePath}"`, { timeout: 10000 }, (error: ExecException | null, stdout: string, stderr: string) => {
                if (error) {
                    reject(new Error(stderr || error.message));
                } else {
                    resolve({ stdout, stderr });
                }
            });
        });
    }
}
